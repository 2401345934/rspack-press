[{"id":0,"title":"HTML 开始","content":"#","routePath":"/html/","lang":"","toc":[],"domain":"","frontmatter":{},"version":""},{"id":1,"title":"link 标签的preload、prefetch、preconnect","content":"#\n\n\n使用#\n\n\n\n初看起来，这三个属性设置起来比较简单，但是如果使用得当，效果却会非常棒。比如 奈飞 通过使用 prefetch 把 TTI (\nTime-to-Interactive) 的时间减少了 30 %。\n\npreload、prefetch 都有助于优化 TTI、FCP ( First Content Paint ) 。为了让大家更好的理解\npreload、prefetch 的好处，我们简单了解一下这两个指标代表的含义。\n\n为了直观的认识，可以打开一个 Chrome 的控制台，进入 LightHouse 跑跑分，下图就是我跑的 Github 的分数，可以看到，头两个指标就是\nFCP（First Contntful Paint） 和 TTI ( Time to Interactive)。\n\nFCP 也叫做首次内容绘制，指的是从开始加载页面内容到任何部分的内容在屏幕上渲染出来了，这里的内容，可以是一个文本，也可以是一个图片（背景图片也算）。\n\nTTI 也叫做可交互时间，计算规则稍微有一点复杂，它是以 FCP 结束的时间作为起始，也就是有任何内容出现在屏幕上了，这个点就作为 TTI 的时间点。\n\n有了起始点之后，它会寻找一个长度至少是 5 S 的安静窗口（安静窗口是没有耗时超过 50 ms\n的任务，并且不超过两个正在处理的请求），找到安静窗口之后，会再往回找，找到离这个安静窗口最近的长任务，这个时间点就是 TTI 的时间点，如果 FCP\n后没有任何长任务，那此时 FCP 就会等于 TTI，上面截图也表现了这一点。\n\n举一个例子来说明 TTI：假设 FCP 时间点是 0.8 S，之后在 1 S 时有了一个长度为 100 ms 的长任务，执行后，就来到了 1.1\nS，之后就没有任何任务和请求了。过了 5 秒，发现找到了一个安静窗口，会再往前找最近的一个长任务，时间点是 1.1 S，那 TTI 就是 1.1 S。\n\n\nTL DR#\n\n * prefetch 用于在浏览器的空闲时间请求资源\n\n * preload 用于提前加载在页面初始化加载（page load）时用到的资源\n\n * preconnect 用于提前和一个网站建立起连接\n\n在谈这三个属性之前，我们先对浏览器请求各种资源的优先级顺序有一个大概的认识，在默认情况下，有如下的划分：\n\n 1. 第一个级别就是这个页面的主资源，它所包含的当前主页（index.html）、 css 资源、font 资源\n\n 2. 第二个级别就是 JS 资源、在视口区域的图片、Fetch API、XHR\n\n 3. 第三个级别可以是我们网站的标题的图标 Favicon\n\n 4. 第四个级别是 async/defer 标签的 JS 资源、不在视口里的图片、视频这些\n\n上面优先级的叙述省略了一些细节，比如 CSS、JS 也是分 early 和 later 的，以至于他们优先级不同，如果想了解完整的内容，可以看 这篇文章\n\n\npreload#\n\n\n\n值得关注的就是 as 属性，preload 的优先级顺序和这个属性指定的资源类型相关。\n\n举一个例子，假如我们指定了 as 的值是 style，也就是把它当做 css 资源，那它的优先级就会变得最高。\n\n但是也有一个例外：虽然 font 的优先级是最高，但把 as 的值指定为 font 并不会把此资源的优先级放到最高，文档专门为 font 的 preload\n指定了优先级：位于第二级。目前来说，除了 font，其他都按照和资源优先级相同的规则。\n\nas 属性可以说是必须要设置的，除了上面可以给优先级排级别以外，还有一个原因：如果不设置的话，它会被作为一个 XHR\n请求去触发，浏览器可能不能正确的认识到，我们其实已经把资源预加载了，这样子就会加载两次了，完全没有了优化的效果。\n\n不指定 as 浏览器也会有警告：\n\n\n\npreload 只会加载，真正执行要等到资源被用到的地方。\n\n\nprefetch#\n\n它的使用方法和 preload 非常像。\n\n首先，prefetch 的请求的优先级是在上面几个的最后面。也就是说，在第五个级别。\n\n明白了这一点，我们大概就知道它的应用场景了，一个典型的应用场景就是 prefetch\n在未来可能打开的路由页面。举一个例子来说明这个问题，假如有一个搜索页面，点击搜索出来的结果是跳转新的路由，其实如果搜索结果好，一般用户都会点击前几条，所以我们就\n可以 prefetch 前几条搜索结果对应的路由。\n\n像我们的现在的应用，一般都会有懒加载，我们可以给非首页但是打开频率很高的页面加 prefetch。\n\n它的使用就是直接加一个 link 标签，这样它就会在浏览器空闲的时候下载了：\n\n\n\n其中 as 的取值有 document 、style、script、images ...\n\n如果使用 webpack ，没有使用 preload 那么坑，可以直接在引入的地方加魔法注释：\n\n\n\n截止目前（2022-08-05），prefetch的支持性没有特别好，只覆盖了 80 % 的浏览器 。所以我们一般都是需要 polyfill 的，可以使用\nXHR 去模拟：\n\n\n\n除了直接给资源加 prefetch 标签。还有一个触发 prefetch 的思路，我们可以在入口到达可视窗口的时候，自动 prefetch。这个库\n就实现了这样的功能。它使用了 Intersection API 监听元素到达可视窗口，到达了就进行 prefetch。\n\n\npreconnect#\n\n它的作用使用了提前和第三方资源建立连接的。在我们请求一个资源之前，可能会涉及 DNS 寻址、TLS 握手、TCP\n握手、重定向等。这期间就花费了很多时间了。如果我们加上 preconnect：\n\n\n\n浏览器就知道我们将要连接这个网站，跳转也好、请求资源也好，它会做好早期的连接工作。但是浏览器只会保留 10 S，如果 10 S 不用就会浪费了这资源了。\n\n还有一个和它很相似的 dns-prefetch，只不过这个只预解析 DNS ：\n\n","routePath":"/html/link标签","lang":"","toc":[{"text":"使用","id":"使用","depth":2,"charIndex":3},{"text":"TL DR","id":"tl-dr","depth":2,"charIndex":822},{"text":"preload","id":"preload","depth":2,"charIndex":1247},{"text":"prefetch","id":"prefetch","depth":2,"charIndex":1654},{"text":"preconnect","id":"preconnect","depth":2,"charIndex":2298}],"domain":"","frontmatter":{},"version":""},{"id":2,"title":"http-equiv","content":"meta标签#\n\n\n概览#\n\nmeta标签一般放在整个html页面的head部分，在MDN中对他这样定义：\n\n 1. meta是文档级元数据元素，用来表示那些不能由其它 HTML 元相关元素（、, 、或 ）之一表示的任何元数据。\n\n 2. 如果设置了 name属性，meta 元素提供的是文档级别的元数据，应用于整个页面。\n\n 3. 如果设置了 http-equiv属性，meta 元素则是编译指令，提供的信息与类似命名的 HTTP 头部相同。\n\n 4. 如果设置了 charset属性，meta 元素是一个字符集声明，告诉文档使用哪种字符编码。\n\n 5. 如果设置了 itemprop 属性，meta 元素提供用户定义的元数据。\n\n\nname属性#\n\nname和content一起使用，前者表示要表示的元数据的名称，后者是元数据的值。\n\n\nauthor#\n\n用来表示网页的作者的名字，例如某个组织或者机构。\n\n\n\n\ndescription#\n\n是一段简短而精确的、对页面内容的描述。以头条和taobao的description标签为例：\n\n\n\n\nkeywords#\n\n与页面内容相关的关键词，使用逗号分隔。某些搜索引擎在遇到这些关键字时，会用这些关键字对文档进行分类。 还是以头条和taobao为例\n\n\n\n\nviewpoint#\n\n为 viewport（视口）的初始大小提供指示。目前仅用于移动设备。\n\n可能你也发现了，我们在vscode中自动生成html的代码片段时，会自动生成：\n\nwidth用来设置 viewport 的宽度为设备宽度;\n\ninitial-scale为设备宽度与 viewport 大小之间的缩放比例。\n\n\n\n\nrobots#\n\n表示爬虫对此页面的处理行为，或者说，应当遵守的规则，是用来做搜索引擎抓取的。\n\n它的content可以为：\n\n 6. all:搜索引擎将索引此网页，并继续通过此网页的链接索引文件将被检索\n\n 7. none:搜索引擎讲忽略此网页\n\n 8. index:搜索引擎索引此网页\n\n 9. follow:搜索引擎继续通过此网页的链接索引搜索其它的网页\n\n\nreferer#\n\n用来指定双核浏览器的渲染方式，比如360浏览器，我们可以通过这个设置来指定360浏览器的渲染方式\n\n\n\n\nhttp-equiv#\n\nhttp-equiv也是和content一起使用，前者表示要表示的元数据的名称，后者是元数据的值。\n\nhttp-equiv 所有允许的值都是特定 HTTP 头部的名称，\n\n\nX-UA-Compatible#\n\n我们最常见的http-equiv值可能就是X-UA-Compatible了，它常常长这个样子：\n\n它是用来是做IE浏览器适配的。\n\nIE=edge告诉浏览器，以当前浏览器支持的最新版本来渲染，IE9就以IE9版本来渲染。\n\nchrome=1告诉浏览器，如果当前IE浏览器安装了Google Chrome Frame插件，就以chrome内核来渲染页面。\n\n\n\n\ncontent-type#\n\n用来声明文档类型和字符集\n\n\n\n\nx-dns-prefetch-control#\n\n一般来说，HTML页面中的a标签会自动启用DNS提前解析来提升网站性能，但是在使用https协议的网站中失效了，我们可以设置：\n\n来打开dns对a标签的提前解析\n\n\n\n\ncache-control、Pragma、Expires#\n\n和缓存相关的设置，但是遗憾的是这些往往不生效，我们一般都通过http headers来设置缓存策略\n\n\n#","routePath":"/html/meta标签","lang":"","toc":[{"text":"author","id":"author","depth":2,"charIndex":370},{"text":"description","id":"description","depth":2,"charIndex":408},{"text":"keywords","id":"keywords","depth":2,"charIndex":473},{"text":"viewpoint","id":"viewpoint","depth":2,"charIndex":554},{"text":"robots","id":"robots","depth":2,"charIndex":717},{"text":"referer","id":"referer","depth":2,"charIndex":900},{"text":"X-UA-Compatible","id":"x-ua-compatible","depth":2,"charIndex":1063},{"text":"content-type","id":"content-type","depth":2,"charIndex":1262},{"text":"x-dns-prefetch-control","id":"x-dns-prefetch-control","depth":2,"charIndex":1294},{"text":"cache-control、Pragma、Expires","id":"cache-controlpragmaexpires","depth":2,"charIndex":1404},{"text":"","id":"","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""}]